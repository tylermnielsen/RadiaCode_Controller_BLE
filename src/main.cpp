/*
 * Copyright (C) 2014 BlueKitchen GmbH
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 * 4. Any redistribution, use, or modification is done solely for
 *    personal benefit and not for any commercial purpose or for
 *    monetary gain.
 *
 * THIS SOFTWARE IS PROVIDED BY BLUEKITCHEN GMBH AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BLUEKITCHEN
 * GMBH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Please inquire about commercial licensing options at
 * contact@bluekitchen-gmbh.com
 *
 */

// #define BTSTACK_FILE__ "gatt_browser.c"

// *****************************************************************************
/* EXAMPLE_START(gatt_browser): GATT Client - Discover Primary Services
 *
 * @text This example shows how to use the GATT Client
 * API to discover primary services and their characteristics of the first found
 * device that is advertising its services.
 *
 * The logic is divided between the HCI and GATT client packet handlers.
 * The HCI packet handler is responsible for finding a remote device,
 * connecting to it, and for starting the first GATT client query.
 * Then, the GATT client packet handler receives all primary services and
 * requests the characteristics of the last one to keep the example short.
 *
 */
// *****************************************************************************

#include <Arduino.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "btstack.h"

// gatt_browser.gatt contains the declaration of the provided GATT Services +
// Characteristics gatt_browser.h    contains the binary representation of
// gatt_browser.gatt it is generated by the build system by calling:
// $BTSTACK_ROOT/tool/compile_gatt.py gatt_browser.gatt gatt_browser.h it needs
// to be regenerated when the GATT Database declared in gatt_browser.gatt file
// is modified #include "gatt_browser.h"

// #define RADIACODE_SERVICE_UUID "e63215e5-7003-49d8-96b0-b024798fb901"
// #define RADIACODE_WRITE_FD_UUID "e63215e6-7003-49d8-96b0-b024798fb901"
// #define RADIACODE_NOTIFY_FD_UUID "e63215e7-7003-49d8-96b0-b024798fb901"

#define RADIACODE_SERVICE_UUID "E63215E5-7003-49D8-96B0-B024798FB901"
#define RADIACODE_WRITE_FD_UUID "E63215E6-7003-49D8-96B0-B024798FB901"
#define RADIACODE_NOTIFY_FD_UUID "E63215E7-7003-49D8-96B0-B024798FB901"

static gatt_client_characteristic_t radiacode_write_char;
static gatt_client_characteristic_t radiacode_notify_char;

static enum gatt_action_t {
  GATT_ACTION_NONE = 0,
  GATT_ACTION_SUBSCRIBE,
} gatt_action;

static gatt_client_notification_t notification_listener;
typedef struct advertising_report {
  uint8_t type;
  uint8_t event_type;
  uint8_t address_type;
  bd_addr_t address;
  uint8_t rssi;
  uint8_t length;
  const uint8_t* data;
} advertising_report_t;

static bd_addr_t cmdline_addr;
static int cmdline_addr_found = 0;

static hci_con_handle_t connection_handle;
static gatt_client_service_t services[40];
static int service_count = 0;
static int service_index = 0;

static btstack_packet_callback_registration_t hci_event_callback_registration;

/* @section GATT client setup
 *
 * @text In the setup phase, a GATT client must register the HCI and GATT client
 * packet handlers, as shown in Listing GATTClientSetup.
 * Additionally, the security manager can be setup, if signed writes, or
 * encrypted, or authenticated connection are required, to access the
 * characteristics, as explained in Section on
 * [SMP](../protocols/#sec:smpProtocols).
 */

/* LISTING_START(GATTClientSetup): Setting up GATT client */

// Handles connect, disconnect, and advertising report events,
// starts the GATT client, and sends the first query.
static void handle_hci_event(uint8_t packet_type, uint16_t channel,
                             uint8_t* packet, uint16_t size);

// Handles GATT client query results, sends queries and the
// GAP disconnect command when the querying is done.
static void handle_gatt_client_event(uint8_t packet_type, uint16_t channel,
                                     uint8_t* packet, uint16_t size);

static void gatt_client_setup(void) {
  // Initialize L2CAP and register HCI event handler
  l2cap_init();

  // Initialize GATT client
  gatt_client_init();

  // Optinoally, Setup security manager
  sm_init();
  sm_set_io_capabilities(IO_CAPABILITY_NO_INPUT_NO_OUTPUT);

  // register for HCI events
  hci_event_callback_registration.callback = &handle_hci_event;
  hci_add_event_handler(&hci_event_callback_registration);
}
/* LISTING_END */

static void printUUID(uint8_t* uuid128, uint16_t uuid16) {
  if (uuid16) {
    Serial.printf("%04x", uuid16);
  } else {
    Serial.printf("%s", uuid128_to_str(uuid128));
  }
}

static void dump_advertising_report(advertising_report_t* e) {
  Serial.printf(
      "    * adv. event: evt-type %u, addr-type %u, addr %s, rssi %u, length "
      "adv %u, data: ",
      e->event_type, e->address_type, bd_addr_to_str(e->address), e->rssi,
      e->length);
  Serial.write(e->data, e->length);
}

static void dump_characteristic(gatt_client_characteristic_t* characteristic) {
  Serial.printf(
      "    * characteristic: [0x%04x-0x%04x-0x%04x], properties 0x%02x, uuid ",
      characteristic->start_handle, characteristic->value_handle,
      characteristic->end_handle, characteristic->properties);
  printUUID(characteristic->uuid128, characteristic->uuid16);
  Serial.printf("\n");
}

static void dump_service(gatt_client_service_t* service) {
  Serial.printf("    * service: [0x%04x-0x%04x], uuid ",
                service->start_group_handle, service->end_group_handle);
  printUUID(service->uuid128, service->uuid16);
  Serial.printf("\n");
}

static void fill_advertising_report_from_packet(advertising_report_t* report,
                                                uint8_t* packet) {
  gap_event_advertising_report_get_address(packet, report->address);
  report->event_type =
      gap_event_advertising_report_get_advertising_event_type(packet);
  report->address_type = gap_event_advertising_report_get_address_type(packet);
  report->rssi = gap_event_advertising_report_get_rssi(packet);
  report->length = gap_event_advertising_report_get_data_length(packet);
  report->data = gap_event_advertising_report_get_data(packet);
}

/* @section HCI packet handler
 *
 * @text The HCI packet handler has to start the scanning,
 * to find the first advertising device, to stop scanning, to connect
 * to and later to disconnect from it, to start the GATT client upon
 * the connection is completed, and to send the first query - in this
 * case the gatt_client_discover_primary_services() is called, see
 * Listing GATTBrowserHCIPacketHandler.
 */

/* LISTING_START(GATTBrowserHCIPacketHandler): Connecting and disconnecting from
 * the GATT client */
static void handle_hci_event(uint8_t packet_type, uint16_t channel,
                             uint8_t* packet, uint16_t size) {
  UNUSED(channel);
  UNUSED(size);

  if (packet_type != HCI_EVENT_PACKET) return;
  advertising_report_t report;

  bd_addr_t target = {0x52, 0x43, 0x06, 0x60, 0x17, 0xDD};

  uint8_t event = hci_event_packet_get_type(packet);
  switch (event) {
    case BTSTACK_EVENT_STATE:
      // BTstack activated, get started
      if (btstack_event_state_get_state(packet) != HCI_STATE_WORKING) break;
      // if (cmdline_addr_found){
      //     Serial.printf("Trying to connect to %s\n",
      //     bd_addr_to_str(cmdline_addr));

      //     gap_connect(cmdline_addr, bd_addr_type_t::BD_ADDR_TYPE_LE_PUBLIC);
      //     break;
      // }
      Serial.printf("BTstack activated, start scanning!\n");
      gap_set_scan_parameters(0, 0x0030, 0x0030);
      gap_start_scan();
      break;
    case GAP_EVENT_ADVERTISING_REPORT:
      fill_advertising_report_from_packet(&report, packet);
      // dump_advertising_report(&report);

      // if(report.address )
      // for(int i = 0; i < 6; i++){
      //     Serial.print(report.address[i], HEX);
      //     Serial.print(" ");
      // }
      // Serial.println();
      // break;
      if (memcmp(report.address, target, 6) != 0) {
        // Serial.println("Not target device, continue scanning...");
        break;
      }
      Serial.printf("Found target device:\n");
      dump_advertising_report(&report);

      // stop scanning, and connect to the device
      gap_stop_scan();
      gap_connect(report.address, (bd_addr_type_t)(report.address_type));
      break;
    case HCI_EVENT_META_GAP:
      // wait for connection complete
      if (hci_event_gap_meta_get_subevent_code(packet) !=
          GAP_SUBEVENT_LE_CONNECTION_COMPLETE)
        break;
      Serial.printf("\nGATT browser - CONNECTED\n");
      connection_handle =
          gap_subevent_le_connection_complete_get_connection_handle(packet);
      // query primary services
      gatt_client_discover_primary_services(handle_gatt_client_event,
                                            connection_handle);
      break;
    case HCI_EVENT_DISCONNECTION_COMPLETE:
      Serial.printf("\nGATT browser - DISCONNECTED\n");
      break;
    default:
      break;
  }
}
/* LISTING_END */

/* @section GATT Client event handler
 *
 * @text Query results and further queries are handled by the GATT client packet
 * handler, as shown in Listing GATTBrowserQueryHandler. Here, upon
 * receiving the primary services, the
 * gatt_client_discover_characteristics_for_service() query for the last
 * received service is sent. After receiving the characteristics for the
 * service, gap_disconnect is called to terminate the connection. Upon
 * disconnect, the HCI packet handler receives the disconnect complete event.
 */

/* LISTING_START(GATTBrowserQueryHandler): Handling of the GATT client queries
 */

static void handle_gatt_client_event(uint8_t packet_type, uint16_t channel,
                                     uint8_t* packet, uint16_t size) {
  UNUSED(packet_type);
  UNUSED(channel);
  UNUSED(size);

  gatt_client_service_t service;
  gatt_client_characteristic_t characteristic;
  switch (hci_event_packet_get_type(packet)) {
    case GATT_EVENT_SERVICE_QUERY_RESULT:
      gatt_event_service_query_result_get_service(packet, &service);
      dump_service(&service);
      services[service_count++] = service;
      break;
    case GATT_EVENT_CHARACTERISTIC_QUERY_RESULT:
      gatt_event_characteristic_query_result_get_characteristic(
          packet, &characteristic);

      if (strcmp(uuid128_to_str(characteristic.uuid128),
                 RADIACODE_NOTIFY_FD_UUID) == 0) {
        Serial.printf("Found RadiaCode Notify Characteristic!\n");
        radiacode_notify_char = characteristic;

        Serial.println("Subscribing to notifications...");
        gatt_action = GATT_ACTION_SUBSCRIBE;
        gatt_client_listen_for_characteristic_value_updates(
            &notification_listener, handle_gatt_client_event, connection_handle,
            &radiacode_notify_char);

        gatt_client_write_client_characteristic_configuration(
            handle_gatt_client_event, connection_handle, &radiacode_notify_char,
            GATT_CLIENT_CHARACTERISTICS_CONFIGURATION_NOTIFICATION);

        dump_characteristic(&characteristic);
      } else if (strcmp(uuid128_to_str(characteristic.uuid128),
                        RADIACODE_WRITE_FD_UUID) == 0) {
        Serial.printf("Found RadiaCode Write Characteristic!\n");
        radiacode_write_char = characteristic;

        dump_characteristic(&characteristic);
      } else {
        Serial.println("unexpected characteristic:");
        dump_characteristic(&characteristic);
      }

      break;
    case GATT_EVENT_QUERY_COMPLETE:

      if (gatt_action == GATT_ACTION_SUBSCRIBE) {
        Serial.println("Subscribed to notifications.");
        break;
      }

      // GATT_EVENT_QUERY_COMPLETE of search characteristics
      if (service_index < service_count) {
        service = services[service_index++];
        Serial.printf(
            "\nGATT browser - CHARACTERISTIC for SERVICE %s, [0x%04x-0x%04x]\n",
            uuid128_to_str(service.uuid128), service.start_group_handle,
            service.end_group_handle);

        gatt_client_discover_characteristics_for_service(
            handle_gatt_client_event, connection_handle, &service);
        break;
      }
      service_index = 0;
      break;

    case GATT_EVENT_NOTIFICATION:
      Serial.println("Received Notification:");
      {
        uint16_t value_handle =
            gatt_event_notification_get_value_handle(packet);
        uint16_t value_length =
            gatt_event_notification_get_value_length(packet);
        const uint8_t* value = gatt_event_notification_get_value(packet);
        Serial.printf("  * handle 0x%04x, length %u, value: ", value_handle,
                      value_length);
        for (int i = 0; i < value_length; i++) {
          Serial.printf("%c", value[i]);
        }
        Serial.printf("\n");
      }
      break;

    default:
      break;
  }
}
/* LISTING_END */

int btstack_main(int argc, const char* argv[]);
int btstack_main(int argc, const char* argv[]) {
  (void)argc;
  (void)argv;

  while (!Serial);
  Serial.println("Start");

  // setup GATT client
  gatt_client_setup();

  // turn on!
  hci_power_control(HCI_POWER_ON);

  return 0;
}

/* EXAMPLE_END */

void setup() {
  Serial.begin(115200);
  btstack_main(0, NULL);
}

void loop() {}